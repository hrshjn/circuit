import fs from 'fs';
import path from 'path';
import { Command } from '../types';
import * as storage from '../storage';
import { readSteps, Step } from '../storage';
import { getElementDescription } from './selector';

export interface DocumentationPage {
  url: string;
  title: string;
  screenshot: string;
  steps: string[];
  timestamp: string;
}

/**
 * Generate documentation for a specific flow
 */
export async function generateDocumentation(flowName: string): Promise<void> {
  const steps = storage.getFlowSteps(flowName);
  if (steps.length === 0) {
    console.log(`[DOCS] No steps found for flow: ${flowName}`);
    return;
  }

  // Create documentation directory
  const docsDir = path.join(process.cwd(), 'documentation', flowName);
  if (!fs.existsSync(docsDir)) {
    fs.mkdirSync(docsDir, { recursive: true });
  }

  // Group steps by page/workflow
  const workflows = groupStepsByWorkflow(steps);
  
  // Generate index page
  generateIndexPage(flowName, workflows, docsDir);
  
  // Generate individual workflow pages
  for (const [workflowName, workflowSteps] of Object.entries(workflows)) {
    generateWorkflowPage(flowName, workflowName, workflowSteps, docsDir);
  }
  
  console.log(`[DOCS] Generated documentation for ${flowName} with ${Object.keys(workflows).length} workflows`);
}

/**
 * Group steps into logical workflows based on URL patterns
 */
function groupStepsByWorkflow(steps: Step[]): Record<string, Step[]> {
  const workflows: Record<string, Step[]> = {};
  
  for (const step of steps) {
    // Extract workflow name from URL
    const url = new URL(step.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // Use the main section as workflow name
    const workflowName = pathParts[1] || 'home';
    
    if (!workflows[workflowName]) {
      workflows[workflowName] = [];
    }
    workflows[workflowName].push(step);
  }
  
  return workflows;
}

/**
 * Generate the main index page
 */
function generateIndexPage(
  flowName: string, 
  workflows: Record<string, Step[]>, 
  docsDir: string
): void {
  const indexPath = path.join(docsDir, 'index.md');
  
  let content = `# ${flowName} Documentation\n\n`;
  content += `Generated on: ${new Date().toLocaleString()}\n\n`;
  content += `## Available Workflows\n\n`;
  
  for (const [workflowName, steps] of Object.entries(workflows)) {
    const pageCount = steps.length;
    content += `- [${formatWorkflowName(workflowName)}](./${workflowName}.md) (${pageCount} pages)\n`;
  }
  
  content += `\n## Overview\n\n`;
  content += `This documentation was automatically generated by crawling the application.\n`;
  content += `Each workflow shows the exact steps to navigate through different features.\n`;
  
  fs.writeFileSync(indexPath, content);
}

/**
 * Generate documentation for a specific workflow
 */
function generateWorkflowPage(
  flowName: string,
  workflowName: string,
  steps: Step[],
  docsDir: string
): void {
  const pagePath = path.join(docsDir, `${workflowName}.md`);
  
  let content = `# ${formatWorkflowName(workflowName)}\n\n`;
  content += `[‚Üê Back to Index](./index.md)\n\n`;
  
  // Add navigation steps
  content += `## Navigation Steps\n\n`;
  
  for (let i = 0; i < steps.length; i++) {
    const step = steps[i];
    const stepNumber = i + 1;
    
    content += `### Step ${stepNumber}: ${getPageTitle(step.url)}\n\n`;
    
    // Add URL
    content += `**URL:** \`${step.url}\`\n\n`;
    
    // Add screenshot
    const screenshotName = path.basename(step.screenshot);
    content += `![Step ${stepNumber} Screenshot](${step.screenshot})\n\n`;
    
    // Add commands if available
    if (step.commandLog && step.commandLog.length > 0) {
      content += `**Actions taken:**\n`;
      for (const command of step.commandLog) {
        content += `- ${commandToMarkdown(command)}\n`;
      }
      content += '\n';
    }
    
    // Add navigation hint for next step
    if (i < steps.length - 1) {
      const nextStep = steps[i + 1];
      const nextCommand = getNavigationCommand(step, nextStep);
      if (nextCommand) {
        content += `**To continue:** ${nextCommand}\n\n`;
      }
    }
    
    content += '---\n\n';
  }
  
  fs.writeFileSync(pagePath, content);
}

/**
 * Format a command for documentation
 */
function commandToMarkdown(command: Command): string {
  switch (command.command) {
    case 'click':
      return `Click on "${getSimpleDescription(command.selector!)}"`;
    case 'fill':
      return `Fill "${getSimpleDescription(
        command.selector!,
      )}" with "${command.value!}"`;
    case 'go_to':
      return `Navigate to ${command.url!}`;
    default:
      return '';
  }
}

/**
 * Get a human-readable description of an element from its selector
 */
function getSimpleDescription(selector: string): string {
    // A simple heuristic to make selectors more readable
    const parts = selector.match(/\[data-testid="([^"]+)"\]|\[role="([^"]+)"\]|:has-text\("([^"]+)"\)|#([^ ]+)|([a-zA-Z0-9_]+)/g);
    if (parts) {
        return parts.map(p => p.replace(/\[|\]|#|:has-text|\(|\)|"|'/g, '').replace('=', ' ')).join(' ');
    }
    return selector;
}

/**
 * Get navigation command between two steps
 */
function getNavigationCommand(currentStep: Step, nextStep: Step): string | null {
  if (!nextStep.commandLog || nextStep.commandLog.length === 0) {
    return null;
  }
  
  const lastCommand = nextStep.commandLog[nextStep.commandLog.length - 1];
  return commandToMarkdown(lastCommand);
}

/**
 * Format workflow name for display
 */
function formatWorkflowName(name: string): string {
  return name
    .split(/[-_]/)
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Extract page title from URL
 */
function getPageTitle(url: string): string {
  try {
    const urlObj = new URL(url);
    const pathParts = urlObj.pathname.split('/').filter(p => p);
    
    if (pathParts.length === 0) {
      return 'Home';
    }
    
    // Use the last meaningful part of the path
    const lastPart = pathParts[pathParts.length - 1];
    return formatWorkflowName(lastPart);
  } catch {
    return 'Page';
  }
}

/**
 * Generate a summary report of all documentation
 */
export async function generateSummaryReport(): Promise<void> {
  const flows = storage.getAllFlows();
  const reportPath = path.join(process.cwd(), 'documentation', 'summary.md');
  
  let content = `# Documentation Summary\n\n`;
  content += `Generated on: ${new Date().toLocaleString()}\n\n`;
  content += `## Documented Applications\n\n`;
  
  for (const flow of flows) {
    const steps = storage.getFlowSteps(flow.name);
    content += `- **${flow.name}**: ${steps.length} pages documented\n`;
  }
  
  fs.writeFileSync(reportPath, content);
  console.log(`[DOCS] Generated summary report at ${reportPath}`);
} 